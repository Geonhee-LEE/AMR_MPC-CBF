# test iniziali
ostacoli sulla terza curva fermi, x0 strane per fare la manovra  -> fatti

single_car_base (v_car=2.5, x0=0,0,0, T=15s) con gli ostacoli fermi (v=0) h=3 e varie gamma (0.1, 0.5, 1.)[oriz=1.5s] e vari orizzonti (0.5s, 0.75s, 1s, 2s, 5s)[gamma=0.5] (con RTI)
Q = np.diag([ 0, 10, 0])
R = np.eye(nu)*10
Qe = np.diag([ 0, 10, 0])

single_car_base (v_car=2.5, x0=0,0,0, T=15s) con gli ostacoli che si muovono (v_obs=1) e varie gamma (0.1, 0.5, 1.)[oriz=1.5s] e vari orizzonti (0.5s, 0.75s, 1s, 2s, 5s)[gamma=0.5] (no RTI)
continuos time come sopra (no RTI possibilmente)


# confronto
discrete_multiple_independent_cars con ostacoli fissi con una gamma (scelta prima)   (con RTI)
discrete_multiple_autonomous_cars con stessi ostacoli fissi con una gamma (scelta prima)   (con RTI)


# confronto stessi parametri
intersection_moving_cars (con 4 ostacoli, da fare) (con RTI)

intersection_moving_cars_sm (con RTI)

# -----------> tutto pronto fino a qua

# dinamico
discreto (ostacoli fissi e mobili) con una sola gamma e Tf
continuo (ostacoli fissi e mobili) con vari K (es. [-100,-100], [-0.5,-0.5],[-100,-1])

# per tutti i test
discretization step = 1/50


(per i gain, valutare in base ai test)
Q = np.diag([ 100, 10, 10])
R = np.eye(nu)*10
Qe = np.diag([ 100, 10, 10])

(estensione dinamica)
Q = np.diag([ 100, 10, 10])
R = np.eye(nu)*1
Qe = np.diag([ 100, 10, 10])